---
title: Create a Lottery with the Randomness Precompile - 使用Randomness Precompile创建Lottery
description: Looking to create a lottery smart contract? Follow this step-by-step tutorial on using Moonbeam's Randomness Precompile (a Solidity interface) to get started.
想要创建一个Lottery智能合约？遵循本教程使用Moonbeam的Randomness Precompile（一个Solidity接口）开始操作
---

# Create a Lottery Contract using the Randomness Precompile - 使用Randomness Precompile创建一个Lottery合约

![Randomness Moonbeam Banner](/images/builders/pallets-precompiles/precompiles/randomness/randomness-banner.png)

_March 15, 2022 | by Erin Shaben_

_本文档更新至2022年3月15日｜作者：Erin Shaben_

## Introduction - 概览 {: #introduction } 

Moonbeam utilizes verifiable random functions (VRF) to generate randomness that can be verified on-chain. A VRF is a cryptographic function that takes some input and produces random values, along with a proof of authenticity that these random values were generated by the submitter. The proof can be verified by anyone to ensure the random values generated were calculated correctly.

Moonbeam使用可验证随机函数（Verifiable Random Functions，VRF）生成可以在链上验证的随机数。VRF是一种利用一些输入值并产生随机数的加密函数，并证明这些数值是由提交者生成。此证明可以由任何人验证，以确保生成的随机数值经过准确的运算。

There are two available sources of randomness that provide random inputs based on block producers' VRF keys and past randomness results: [local VRF](/learn/features/randomness/#local-vrf){target=_blank} and [BABE epoch randomness](/learn/features/randomness/#babe-epoch-randomness){target=_blank}. Local VRF is determined directly within Moonbeam using the collator of the block's VRF key and the last block's VRF output. On the other hand, [BABE](https://wiki.polkadot.network/docs/learn-consensus#block-production-babe){target=_blank} epoch randomness is based on all the VRF produced by the relay chain validators during a complete [epoch](https://wiki.polkadot.network/docs/glossary#epoch){target=_blank}.

目前有两种提供随机输入的可用随机数来源，分别基于区块生产者的VRF私钥以及过去的随机数结果：[本地VRF](/learn/features/randomness/#local-vrf){target=_blank}和[BABE Epoch随机数](/learn/features/randomness/#babe-epoch-randomness){target=_blank}。本地VRF在Moonbeam中使用区块VRF私钥的收集人以及最新区块的VRF输出值决定。而[BABE](https://wiki.polkadot.network/docs/learn-consensus#block-production-babe){target=_blank} Epoch随机数基于所有由中继链验证人在完整[Epoch](https://wiki.polkadot.network/docs/glossary#epoch){target=_blank}期间生产的VRF。

For more information on the two sources of randomness, how the request and fulfillment process works, and security considerations, please refer to the [Randomness on Moonbeam](/learn/features/randomness){target=_blank} page.

获取关于这两种随机数的更多信息，包括如何请求和完成流程运作模式，以及安全因素，请参考[Moonbeam上的随机数](/learn/features/randomness){target=_blank}页面。

Moonbeam provides a Randomness Precompile, which is a Solidity interface that enables smart contract developers to generate randomness via local VRF or BABE epoch randomness using the Ethereum API. Moonbeam also provides a Randomness Consumer Solidity contract that your contract must inherit from in order to consume fulfilled randomness requests.

Moonbeam提供Randomness Precompile，这是一个Solidity接口，能够使智能合约开发者使用以太坊API通过本地VRF或BABE epoch随机数生成随机数。Moonbeam也提供Randomness Consumer Solidity合约，您的合约必须自该合约继承才能使用已完成的随机数请求。

This guide will show you how to use the Randomness Precompile and Randomness Consumer contract to create a lottery where the winners will randomly be selected.

本教程将向您展示如何使用Randomness Precompile和Randomness Consumer创建一个随机挑选获胜者的lottery合约。

## Checking Prerequisites - 查看先决条件 {: #checking-prerequisites }

For this tutorial, you'll need the following:

在开始操作之前，您需要准备以下内容：

- Create or have three accounts on Moonbase Alpha to test out the lottery contract
- 在Moonbase Alpha上创建/拥有三个账户，用于测试lottery合约
- All of the accounts will need to be funded with `DEV` tokens. 所有的账户必须拥有一些`DEV` Token
 --8<-- 'text/faucet/faucet-list-item.md'
- An empty Hardhat project that is configured for the Moonbase Alpha TestNet. For step-by-step instructions, please refer to the [Creating a Hardhat Project](/builders/build/eth-api/dev-env/hardhat/#creating-a-hardhat-project){target=_blank} and the [Hardhat Configuration File](/builders/build/eth-api/dev-env/hardhat/#hardhat-configuration-file){target=_blank} sections of our Hardhat documentation page
- 一个配置Moonbase Alpha测试网的空白Hardhat项目。要获取详细操作教程，请参考[创建一个Hardhat项目](/builders/build/eth-api/dev-env/hardhat/#creating-a-hardhat-project){target=_blank}和Hardhat文档网站的[Hardhat配置文件](/builders/build/eth-api/dev-env/hardhat/#hardhat-configuration-file){target=_blank}部分
- Install the [Hardhat Ethers plugin](https://hardhat.org/plugins/nomiclabs-hardhat-ethers.html){target=_blank}. This provides a convenient way to use the [Ethers.js](/builders/build/eth-api/libraries/ethersjs/){target=_blank} library to interact with the network from your Hardhat project:
- 安装[Hardhat Ethers插件](https://hardhat.org/plugins/nomiclabs-hardhat-ethers.html){target=_blank}。这将为您提供更简便的方式以使用[Ethers.js](/builders/build/eth-api/libraries/ethersjs/){target=_blank}库与Hardhat项目中的网络交互：

    ```
    npm install @nomiclabs/hardhat-ethers
    ```

!!! note 注意事项
    --8<-- 'text/common/endpoint-examples.md'

## Contract Setup - 合约设置 {: #contracts }

The following are the contracts that we'll be working with today to create our lottery:

以下为我们本次操作指南中创建lottery会用到的合约：

- `Randomness.sol` - the [Randomness Precompile](/builders/pallets-precompiles/precompiles/randomness){target=_blank}, which is a Solidity interface that allows you to request randomness, get information about randomness requests, fulfill requests, and more
- `Randomness.sol` - [Randomness Precompile](/builders/pallets-precompiles/precompiles/randomness){target=_blank}，这是一个Solidity接口，允许您请求随机数、获取关于随机数请求、完成请求等信息
- `RandomnessConsumer.sol` - the [Randomness Consumer](/builders/pallets-precompiles/precompiles/randomness#randomness-consumer-solidity-interface){target=_blank}, which is an abstract Solidity contract that is used to interact with the Randomness Precompile. This contract is responsible for validating the origin of randomness requests, ensuring the Randomness Precompile is always the origin, and fulfilling requests
- `RandomnessConsumer.sol` - the [Randomness Consumer](/builders/pallets-precompiles/precompiles/randomness#randomness-consumer-solidity-interface){target=_blank}，这是一个抽象的Solidity合约，用于与Randomness Precompile交互。此合约负责验证随机数请求的来源，确保Randomness Precompile始终是origin，并完成请求
- `Lottery.sol` - an example lottery contract that we'll be building in this guide together. It will rely on the Randomness Precompile and Consumer to request random words that will be used to select a winner for our lottery
- `Lottery.sol` - 一个示例lottery合约，我们将在本教程中构建此合约。这将根据Randomness Precompile和Randomness Consumer来请求用于挑选获胜者的随机词

If you don't already have a `contracts` directory in your Hardhat project, you can create a new directory:

如果您尚未在Hardhat项目中创建`contracts`目录，您需要创建一个新目录：

```
mkdir contracts && cd contracts
```

Then you can create the following three files, one for each of the aforementioned contracts:

然后您可以创建以下三个文件，每个文件对应上述合约：

```
touch Randomness.sol RandomnessConsumer.sol Lottery.sol
```

In the `Randomness.sol` file, you can paste in the [Randomness Precompile contract](https://github.com/PureStake/moonbeam/blob/master/precompiles/randomness/Randomness.sol){target=_blank}. Similarly, in the `RandomnessConsumer.sol` file, you can paste in the [Randomness Consumer contract](https://github.com/PureStake/moonbeam/blob/master/precompiles/randomness/RandomnessConsumer.sol){target=_blank}.

在`Randomness.sol`文件中，您可以粘贴[Randomness Precompile合约](https://github.com/PureStake/moonbeam/blob/master/precompiles/randomness/Randomness.sol){target=_blank}。同样的，在`RandomnessConsumer.sol`文件中，您可以粘贴[Randomness Consumer合约](https://github.com/PureStake/moonbeam/blob/master/precompiles/randomness/RandomnessConsumer.sol){target=_blank}。

We'll start adding the functionality to the `Lottery.sol` contract in the following section.

我们将在以下部分开始添加功能至`Lottery.sol`合约。

## Create the Lottery Smart Contract - 创建Lottery智能合约 {: #write-the-lottery-contract }

At a high level, the lottery contract we're creating will define the rules of the lottery, enable participation, and use randomly generated words to select winners fairly. We'll be requesting the random words via the Randomness Precompile. Then we'll use the Randomness Consumer interface to consume the results of the fulfilled request so that our contract can use the randomly generated words to select the winners and pay them out. We'll break down each step of the process as we build the lottery contract, but for now, you can review the following diagram for an overview of the process.

从更高层面来说，我们正在创建的lottery合约将定义lottery规则，允许参与并使用随机生成的词来公平挑选获胜者。然后，我们将使用Randomness Consumer接口生成已完成请求的结果，以便我们的合约可以使用随机生成的词挑选获胜者并支付奖励。我们将会在构建lottery合约时演示分步流程。但是现在，您可以查看下图了解整个流程。

![Diagram of the Lottery process.](/images/tutorials/eth-api/randomness-lottery/lottery-1.png)

**This contract is for educational purposes only and is not meant for production use.**

**此合约仅用于演示目的，不可用于生产环境。**

To get started, let's set up our lottery contract. We'll need to:

开始之前，请先设置lottery合约。为此，您需要：

- Import the `Randomness.sol` precompile and `RandomnessConsumer.sol` interface
- 导入`Randomness.sol`预编译和`RandomnessConsumer.sol`接口
- Inherit the Randomness Consumer interface
- 继承Randomness Consumer接口
- Create a variable for the Randomness Precompile so we can easily access it's functions later on
- 为Randomness Precompile创建变量，以便我们后续轻松访问其函数

```sol
// SPDX-License-Identifier: GPL-3.0-only
pragma solidity >=0.8.0;

import "./Randomness.sol";
import {RandomnessConsumer} from "./RandomnessConsumer.sol";

contract Lottery is RandomnessConsumer {
    // Randomness Precompile interface
    Randomness public randomness =
        Randomness(0x0000000000000000000000000000000000000809);
}
```

### Define Parameters for the Lottery and Randomness Request - 为Lottery和随机数请求定义参数 {: #define-parameters }

Next we're going to need to define the rules of our lottery, such as:

接下来，我们需要为lottery定义规则，例如：

- The participation fee
- 参与费
- The minimum and maximum number of participants
- 最低/最高参与人数
- The minimum length of the lottery
- lottery最短长度
- The number of winners
- 获胜者人数

Inside of the `Lottery` contract, you can add these parameters:

在`Lottery`合约中，您可以添加以下参数：

```sol
// The number of winners. This number corresponds to how many random words
// will be requested. Cannot exceed MAX_RANDOM_WORDS (from the Randomness
// Precompile)
uint8 public NUM_WINNERS = 2;

// The number of blocks before the request can be fulfilled (for Local VRF
// randomness). The MIN_VRF_BLOCKS_DELAY (from the Randomness Precompile) 
// provides a minimum number that is safe enough for games with low economical
// value at stake. Increasing the delay slightly reduces the probability 
// (already very low) of a collator being able to predict the pseudo-random number
uint32 public VRF_BLOCKS_DELAY = MIN_VRF_BLOCKS_DELAY;

// The minimum number of participants to start the lottery
uint256 public MIN_PARTICIPANTS = 3;

// The maximum number of participants allowed to participate. It is important 
// to limit the total jackpot (by limiting the number of participants) to
// guarantee the economic incentive of a collator to avoid trying to influence
// the pseudo-random. (See Randomness.sol for more details)
uint256 public MAX_PARTICIPANTS = 20;

// The fee needed to participate in the lottery. Will go into the jackpot
uint256 public PARTICIPATION_FEE = 100000 gwei;
```

We will also need to define some parameters specifically related to requesting randomness:

我们也需要定义一些请求随机数特别相关的参数：

- The gas limit for the transaction that fulfills a randomness request
- 完成随机数请求的交易gas限制
- The minimum fee needed to start the lottery and request the random words. Each request for randomness requires a fulfillment fee. The purpose of this fee is to pay for the fulfillment of a randomness request, which allows anyone to fulfill a request since the request will already have been paid for. When submitting a randomness request, a refund account can be specified, where any excess fees will be returned to. Our contract will be set up so that the owner of the lottery contract will receive the refund
- 开始抽奖和请求随机词所需的最低费用。每个随机数请求都需要支付执行费用。此费用的目的是支付随机数请求的执行费用，以允许任何人完成请求，因为该请求已支付费用。当提交随机数请求时，需要指定退款账户，用于接收多余的退款。设置合约时需要设置lottery合约的所有者将收到退款
- A salt prefix and the global request count, both of which will be used to generate unique randomness requests
- salt prefix和全局请求计数都将用于生成唯一的随机数请求

You can go ahead and add these parameters: 

接下来，您可以添加以下参数：

```
// The gas limit allowed to be used for the fulfillment, which depends on the
// code that is executed and the number of words requested. Test and adjust
// this limit based on the size of the request and the processing of the 
// callback request in the fulfillRandomWords() function
uint64 public FULFILLMENT_GAS_LIMIT = 100000;

// The minimum fee needed to start the lottery. This does not guarantee that 
// there will be enough fee to pay for the gas used by the fulfillment. 
// Ideally it should be over-estimated considering possible fluctuation of 
// the gas price. Additional fee will be refunded to the caller
uint256 public MIN_FEE = FULFILLMENT_GAS_LIMIT * 1 gwei;

// A string used to allow having different salt than other contracts
bytes32 public SALT_PREFIX = "my_demo_salt_change_me";

// Stores the global number of requests submitted. This number is used as a
// salt to make each request unique
uint256 public globalRequestCount;

```

Aside from these parameters, we'll need to create some variables which will be used to keep track of the current lottery:

除了这些参数，我们需要创建一些变量，用于追踪当前的lottery：

- The current request ID
- 当前的请求ID
- The list of current participants
- 当前的参与者列表
- The jackpot
- 奖池设置
- The owner of the lottery contract. This is necessary because only the owner of the contract will be allowed to start the lottery
- lottery合约的所有者。这是必不可少的，因为只有合约所有者才有权限开启抽奖
- The source of randomness (local VRF or BABE epoch) that is being used
- 所使用的随机数来源（本地VRF或BABE epoch）

```
// The current request id
uint256 public requestId;

// The list of current participants
address[] public participants;

// The current amount of token at stake in the lottery
uint256 public jackpot;

// the owner of the contract
address owner;

// Which randomness source to use. This correlates to the values in the
// RandomnessSource enum in the Randomness Precompile
Randomness.RandomnessSource randomnessSource;
```

### Create the Constructor - 创建构造函数 {: #create-constructor }

Now that we have completed the initial set up of all of the variables required for the lottery, we can start to code the functions that will bring the lottery to life. First, we'll start off by creating a constructor function.

现在，我们已经完成了lottery所需的所有变量的初始设置，接下来我们可以开始编写函数以设置lottery。首先，我们将从创建构造函数开始。

The constructor will accept a *uint8* as the randomness source, which corresponds to the index of the type of randomness defined in the [`RandomnessSource` enum](https://github.com/PureStake/moonbeam/blob/master/precompiles/randomness/Randomness.sol#L44-L47){target=_blank}, located in the Randomness Precompile. So, we can either pass in `0` for local VRF or `1` for BABE epoch randomness. It will also be `payable`, as we'll submit the deposit at the time of deployment and will be used to perform the randomness request later on.

构造函数接受*uint8*作为随机数来源，这对应[`RandomnessSource` enum](https://github.com/PureStake/moonbeam/blob/master/precompiles/randomness/Randomness.sol#L44-L47){target=_blank}中定义的随机数类型的索引，位于Randomness Precompile中。因此，我们需要为本地VRF传入`0`或者为BABE epoch随机数传入`1`。此函数将是`payable`，需要在部署时提交保证金并在后续用于执行随机数请求

The [deposit](https://github.com/PureStake/moonbeam/blob/master/precompiles/randomness/Randomness.sol#L17){target=_blank} is defined in the Randomness Precompile and is required in addition to the fulfillment fee. The deposit will be refunded to the original requester, which in our case is the owner of the contract, after the request has been fulfilled. If a request never gets fulfilled, it will expire and need to be purged. Once it is purged, the deposit will be returned.

[保证金](https://github.com/PureStake/moonbeam/blob/master/precompiles/randomness/Randomness.sol#L17){target=_blank}在Randomness Precompile中定义，这是和执行费用一样必不可少的。在完成请求后，保证金将退还给初始请求者，在本示例中为合约的所有者。如果未完成请求，则该请求会过期且需要被清除。 请求清除后，保证金将被退还。

```
constructor(
    Randomness.RandomnessSource source
) payable RandomnessConsumer() {
    // Because this contract can only perform one randomness request at a time,
    // we only need to have one required deposit
    uint256 requiredDeposit = randomness.requiredDeposit();
    if (msg.value < requiredDeposit) {
        revert("Deposit too Low");
    }
    // Update parameters
    randomnessSource = source;
    owner = msg.sender;
    globalRequestCount = 0;
    jackpot = 0;
    // Set the requestId to the maximum allowed value by the precompile (64 bits)
    requestId = 2 ** 64 - 1;
}
```

### Add Logic to Participate in the Lottery - 为Lottery中的参与者添加逻辑 {: #participate-logic }

Next we can create the function that will allow users to participate in the lottery. The `participate` function will be `payable` as each participant will need to submit a participation fee. 

接下来，我们可以创建函数，以允许用户参与到lottery中。`participate`函数将是`payable`，因为参与者需要提交参与费用。

The `participate` function will include the following logic:

`participate`函数将包含以下逻辑：

- Check that the lottery hasn't started yet using the [`getRequestStatus` function](https://github.com/PureStake/moonbeam/blob/master/precompiles/randomness/Randomness.sol#L96-L99){target=_blank} of the Randomness Precompile. This function returns the status as defined by the [`RequestStatus` enum](https://github.com/PureStake/moonbeam/blob/master/precompiles/randomness/Randomness.sol#L34-L39){target=_blank}. If the status is anything other than `DoesNotExist`, then the lottery has already been started
- 使用Randomness Precompile的[`getRequestStatus` function](https://github.com/PureStake/moonbeam/blob/master/precompiles/randomness/Randomness.sol#L96-L99){target=_blank}检查lottery是否尚未开始。此函数将返回通过[`RequestStatus` enum](https://github.com/PureStake/moonbeam/blob/master/precompiles/randomness/Randomness.sol#L34-L39){target=_blank}定义的状态。如果状态不是`DoesNotExist`，则表示lottery已开始
- Check that the participation fee meets the requirement
- 检查参与费用是否满足要求
- If both of the above are true, then the participant will be added to the list of participants and their participation fee will be added to the jackpot
- 如果上述两项返回true，则参与者将被添加至参与者列表当中，他们的参与费用将被加入到奖池中

```sol
function participate() external payable {
    // We check that the lottery hasn't started yet
    if (
        randomness.getRequestStatus(requestId) !=
        Randomness.RequestStatus.DoesNotExist
    ) {
        revert("Request already initiated");
    }

    // Each player must submit a fee to participate, which is added to
    // the jackpot
    if (msg.value != PARTICIPATION_FEE) {
        revert("Invalid participation fee");
    }
    participants.push(msg.sender);
    jackpot += msg.value;
}
```

!!! challenge 挑战
    In the above function, we check that the lottery hasn't started yet, but what if we want to know the exact status of the lottery? Create a function that solves this problem and returns the status of the lottery.

在上述函数中，我们检查了lottery尚未开始，但是想要了解lottery的明确状态，需要创建一个函数来解决此问题并返回lottery状态。

### Add Logic to Start the Lottery and Request Randomness 添加逻辑以启动Lottery和请求随机数 {: #start-lottery-logic }

The logic for starting the lottery contains a crucial component: requesting randomness. As previously mentioned, only the owner of the lottery contract will be able to start the lottery. As such, the owner will need to submit the fulfillment fee for the request.

启动lottery的逻辑包含一个重要的组件：请求随机数。如上所述，只有lottery合约的所有者才有权限开启lottery。这样一来，所有者需要为请求提交执行费用。

The `startLottery` function will include the following logic:

`startLottery`函数将包含以下逻辑：

- Check that the lottery hasn't started yet, as we did in the `participate` function
- 检查lottery是否尚未开始，操作方式如`participate`函数所示
- Check that there is an acceptable number of participants
- 检查是否有参与者数量上限
- Check that the fulfillment fee meets the minimum requirements 
- 检查执行费用是否满足最低要求
- Check that the balance of the contract is enough to pay for the deposit. Remember how the constructor accepts the request deposit? That deposit is stored in the contract until this function is called
- 检查合约余额是否足够支付保证金。正如构造函数接受请求保证金的方式，保证金将存储于合约中直到函数被调用
- If all of the above are true, we submit the randomness request via the Randomness Precompile along with the fulfillment fee. Depending on the source of randomness, either the [`requestLocalVRFRandomWords` or the `requestRelayBabeEpochRandomWords` function](https://github.com/PureStake/moonbeam/blob/master/precompiles/randomness/Randomness.sol#L110-L167){target=_blank} of the Randomness Precompile will be called along with the following parameters:
- 如果上述函数均返回true，我们将通过Randomness Precompile和执行费用提交随机数请求。根据随机数来源，Randomness Precompile的[`requestLocalVRFRandomWords`或`requestRelayBabeEpochRandomWords`函数](https://github.com/PureStake/moonbeam/blob/master/precompiles/randomness/Randomness.sol#L110-L167){target=_blank}将和以下参数一起被调用：
    - The address where excess fees will be refunded to
    - 接收多余费用退款的地址
    - The fulfillment fee
    - 执行费用
    - The gas limit to use for the fulfillment
    - 完成请求的gas上限
    - The salt, which is a string that is mixed with the randomness seed to obtain different random words. The `globalRequestCount` is used to ensure uniqueness
    - salt，这是一个字符串，与随机助记词共同使用以获取不同的随机词。`globalRequestCount`用于确保独特性
    - The number of random words requested, which is based off the number of winners that will be selected
    - 请求随机词的数量，基于挑选的获胜者数量设定
    - (For local VRF only) The delay, which is the number of blocks that must pass before the request can be fulfilled
    - （仅支持本地VRF）延迟时间，在完成请求之前必须通过的区块数量

Since the lottery function should only be called by the owner, we'll also add in an `onlyOwner` modifer that requires the `msg.sender` to be the `owner`.

由于lottery函数仅限所有者调用，因此我们也需要添加`onlyOwner`修饰符来要求`msg.sender`为`owner`。

```
function startLottery() external payable onlyOwner {
    // Check we haven't started the randomness request yet
    if (
        randomness.getRequestStatus(requestId) !=
        Randomness.RequestStatus.DoesNotExist
    ) {
        revert("Request already initiated");
    }
    // Check that the number of participants is acceptable
    if (participants.length < MIN_PARTICIPANTS) {
        revert("Not enough participants");
    }
    if (participants.length >= MAX_PARTICIPANTS) {
        revert("Too many participants");
    }
    // Check the fulfillment fee is enough
    uint256 fee = msg.value;
    if (fee < MIN_FEE) {
        revert("Not enough fee");
    }
    // Check there is enough balance on the contract to pay for the deposit.
    // This would fail only if the deposit amount required is changed in the
    // Randomness Precompile.
    uint256 requiredDeposit = randomness.requiredDeposit();
    if (address(this).balance < jackpot + requiredDeposit) {
        revert("Deposit too low");
    }

    if (randomnessSource == Randomness.RandomnessSource.LocalVRF) {
        // Request random words using local VRF randomness
        requestId = randomness.requestLocalVRFRandomWords(
            msg.sender,
            fee,
            FULFILLMENT_GAS_LIMIT,
            SALT_PREFIX ^ bytes32(globalRequestCount++),
            NUM_WINNERS,
            VRF_BLOCKS_DELAY
        );
    } else {
        // Requesting random words using BABE Epoch randomness
        requestId = randomness.requestRelayBabeEpochRandomWords(
            msg.sender,
            fee,
            FULFILLMENT_GAS_LIMIT,
            SALT_PREFIX ^ bytes32(globalRequestCount++),
            NUM_WINNERS
        );
    }
}

modifier onlyOwner() {
    require(msg.sender == owner);
    _;
}
```

### Add Logic to Fulfill the Randomness Request - 添加逻辑以完成随机数请求 {: #fulfill-randomness-logic }

In this section, we'll be adding in two functions required to request fulfillment and handle the result of the fulfillment: `fulfillRequest` and `fulfillRandomWords`.

在这一部分，我们将添加完成请求和处理请求结果的两个函数：`fulfillRequest`和`fulfillRandomWords`。

Our `fulfillRequest` function will call the [`fulfillRequest` method](https://github.com/PureStake/moonbeam/blob/master/precompiles/randomness/Randomness.sol#L173){target=_blank} of the Randomness Precompile. When this method is called, under the hood the [`rawFulfillRandomWords` method](https://github.com/PureStake/moonbeam/blob/master/precompiles/randomness/RandomnessConsumer.sol#L114-L125){target=_blank} of the Randomness Consumer is called, which will verify that the call originated from the Randomness Precompile. From there, the [`fulfillRandomWords` function](https://github.com/PureStake/moonbeam/blob/master/precompiles/randomness/RandomnessConsumer.sol#L107-L109){target=_blank} of the Randomness Consumer contract is called and the requested number of random words are computed using the block's randomness result and a given salt, and then it is returned. If the fulfillment was successful, the `FulfillmentSucceeded` event will be emitted; otherwise, the `FulfillmentFailed` event will be emitted.

`fulfillRequest`函数将调用Randomness Precompile的[`fulfillRequest`函数](https://github.com/PureStake/moonbeam/blob/master/precompiles/randomness/Randomness.sol#L173){target=_blank}。在调用此函数时，会在hood下调用Randomness Consumer的[`rawFulfillRandomWords`函数](https://github.com/PureStake/moonbeam/blob/master/precompiles/randomness/RandomnessConsumer.sol#L114-L125){target=_blank}，这将验证调用来自Randomness Precompile。此处调用Randomness Consumer合约的[`fulfillRandomWords`函数](https://github.com/PureStake/moonbeam/blob/master/precompiles/randomness/RandomnessConsumer.sol#L107-L109){target=_blank}，并使用区块的随机数结果和给定salt计算请求的随机词数量，然后将其返回。如果请求成功完成，将发出`FulfillmentSucceeded`事件；反之，将发出`FulfillmentFailed`事件。

For fulfilled requests, the cost of execution will be refunded from the request fee to the caller of `fulfillRequest`. Then any excess fees and the request deposit are transferred to the specified refund address.

对于已完成的请求，执行费用将从请求费用中退还给`fulfillRequest`的调用者。然后，任何多余的费用和请求保证金将转移给指定退款地址。

Our `fulfillRandomWords` function defines a callback, the `pickWinners` function, that is responsible for handling the fulfillment. So, in our case, the callback will use the random words to select a winner and payout the winnings. The signature of our `fulfillRandomWords` function must match the signature of the Randomness Consumer's `fulfillRandomWords` function.

`fulfillRandomWords`函数定义回调函数`pickWinners`，其负责处理完成请求。在本示例中，回调函数将使用随机词挑选获胜者并支付奖励。`fulfillRandomWords`函数的签名必须与Randomness Consumer的`fulfillRandomWords`函数的签名一致。


```
function fulfillRequest() public {
    randomness.fulfillRequest(requestId);
}

function fulfillRandomWords(
    uint256 /* requestId */,
    uint256[] memory randomWords
) internal override {
    pickWinners(randomWords);
}
```

We'll create the logic for the `pickWinners` function in the next section.

我们将在下一部分为`pickWinners`函数创建逻辑。

!!! challenge 挑战
    What if gas prices change significantly before we request the fulfillment, and as a result this function fails? Currently, we wouldn't be able to increase the fulfillment fee. Create a function that solves this problem and allows us to increase the fulfillment fee.

如果在请求完成之前，因为gas价格变化很大而导致此函数失败。目前我们无法增加执行费用，但是我们可以通过创建一个函数来解决此问题并允许我们增加执行费用。

### Add Logic to Pick the Lottery Winners - 添加逻辑以挑选Lottery获胜者 {: #pick-winners-logic }

The last step for our lottery contract will be to create the `pickWinners` function, which, as previously mentioned, is responsible for using the random words to select a winner of the lottery.

lottery合约的最后一步是创建`pickWinners`函数，如上所述，该函数负责使用随机词为lottery挑选获胜者。

The `pickWinners` function contains the following logic:

`pickWinners`函数包含以下逻辑：

- Determine the number of winners. This is only necessary if you happened to change either the `NUM_WINNERS` or the number of `MIN_PARTICIPANTS`, so that the `NUM_WINNERS` is greater than the `MIN_PARTICIPANTS`
- 确定获胜者数量。如果您修改了`NUM_WINNERS`或`MIN_PARTICIPANTS`的数量时必须设置此值，因为`NUM_WINNERS`需大于`MIN_PARTICIPANTS`
- Calculate the amount to be awarded to the winners based on the amount in the jackpot and the total number of winners
- 根据奖池中的数量和获胜者总人数计算获胜者的奖金数量
- Determine the winners by using the random words
- 使用随机词确定获胜者
- Distribute the winnings to each of the winners, making sure to deduct the winnings from the jackpot before transferring them
- 为每位获胜者分发奖励，确保在分发之前将奖励从奖池中移除

```
// This function is called only by the fulfillment callback
function pickWinners(uint256[] memory randomWords) internal {
    // Get the total number of winners to select
    uint256 totalWinners = NUM_WINNERS < participants.length
        ? NUM_WINNERS
        : participants.length;

    // The amount distributed to each winner
    uint256 amountAwarded = jackpot / totalWinners;
    for (uint32 i = 0; i < totalWinners; i++) {
        // This is safe to index randomWords with i because we requested
        // NUM_WINNERS random words
        uint256 randomWord = randomWords[i];

        // Using modulo is not totally fair, but fair enough for this demo
        uint256 index = randomWord % participants.length;
        address payable winner = payable(participants[index]);
        delete participants[index];
        jackpot -= amountAwarded;
        winner.transfer(amountAwarded);
    }
}
```

Congratulations! You've gone through the entire process of creating the `Lottery.sol` contract! You can view the completed version of the [`Lottery.sol` contract on GitHub](https://raw.githubusercontent.com/PureStake/moonbeam-docs/master/.snippets/code/randomness/Lottery.sol){target=_blank}. Remember, **this contract is for educational purposes only and is not meant for production use.**

恭喜您！您已经完成了创建`Lottery.sol`合约的整个过程了！您可以在gitHub上查看[`Lottery.sol`合约](https://raw.githubusercontent.com/PureStake/moonbeam-docs/master/.snippets/code/randomness/Lottery.sol){target=_blank}的完整版本。请注意，**此合约仅用于演示目的，不可用于生产环境。**

!!! challenge 挑战
    To make the contract easier to work with, add some events for when a lottery has started, a winner has been chosen, and a winner has been awarded.

您可以在开始创建lottery、选择获胜者或分配奖励给获胜者时添加一些事件，以便让合约更易于使用。

## Interact with the Lottery Contract - 与Lottery合约交互 {: #interact-with-lottery-contract }

Now that we've gone through and created our lottery contract, let's deploy it and start a lottery!

现在，我们已经了解并创建了lottery合约，接下来可以开始部署并启动lottery。

### Compile & Deploy the Lottery Contract - 编译&部署Lottery合约 {: #compile-deploy-lottery-contract }

To compile our contracts, you can simply run:

要部署合约，您可以简单运行：

```
npx hardhat compile
```

![Compile the contracts using Hardhat's compile command.](/images/tutorials/eth-api/randomness-lottery/lottery-2.png)

After compilation, an `artifacts` directory is created: it holds the bytecode and metadata of the contracts, which are `.json` files. It’s a good idea to add this directory to your `.gitignore`.

编译后，将会创建`artifacts`目录：这将存放合约的字节码和元数据，即`.json`文件。建议您将此目录添加至`.gitignore`。

Before we can deploy the `Lottery.sol` contract, we'll need to create a deployment script. 

在开始部署`Lottery.sol`合约之前，我们需要创建一个部署脚本。

You can create a new directory for the script and name it `scripts` and add a new file to it called `deploy.js`:

您可以为脚本创建一个新目录并命名为`scripts`，然后向其添加名为`deploy.js`的新文件：

```
mkdir scripts && 
touch scripts/deploy.js
```

Now to write the deployment script we can use `ethers`. Because we'll be running it with Hardhat, we don't need to import any libraries. We can simply take the following steps:

我们可以使用`ethers`编写部署脚本。我们将使用Hardhat运行此脚本，因此无需导入任何其他库，只需简单执行以下步骤：

1. Create a local instance of the lottery contract with the `getContractFactory` method

   使用`getContractFactory`函数创建一个lottery合约的本地示例

2. Get the deposit required for a randomness request using the `requiredDeposit` function of the Randomness Precompile

   使用Randomness Precompile的`requiredDeposit`函数获取随机数请求所需的保证金

3. Use the `deploy` method that exists within this instance to instantiate the smart contract. You can pass in `0` to use local VRF randomness or `1` for BABE epoch randomness. For this example, we'll use local VRF randomness. We'll also need to submit the deposit upon deployment

   使用存在于本实例中的`deploy`函数以实例化智能合约。您可以传入`0`以使用VRF随机数或者传入`1`以使用BABE epoch随机数。在本示例中，我们使用的是本地VRF随机数。我们也需要在部署时提交保证金

4. Wait for the deployment by using `deployed`

   使用`deployed`等待部署

5. Once deployed, we can fetch the address of the contract using the contract instance

   部署后，我们可以使用合约实例获取合约地址

```js
async function main() {
  // 1. Get the contract to deploy
  const Lottery = await ethers.getContractFactory('Lottery');

  // 2. Get the required deposit amount from the Randomness Precompile
  const Randomness = await ethers.getContractAt(
    'Randomness',
    '0x0000000000000000000000000000000000000809'
  );
  const deposit = await Randomness.requiredDeposit();

  // 3. Instantiate a new Lottery smart contract that uses local VRF
  // randomness and pass in the required deposit
  const lottery = await Lottery.deploy(0, { value: deposit });
  console.log('Deploying Lottery...');

  // 4. Waiting for the deployment to resolve
  await lottery.deployed();

  // 5. Use the contract instance to get the contract address
  console.log('Lottery deployed to:', lottery.address);
}

main()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error(error);
    process.exit(1);
  });

```

To deploy our lottery contract, we'll use the `run` command and specify `moonbase` as the network:

要部署lottery合约，我们将使用`run`命令并将`moonbase`指定为网络：

```
npx hardhat run --network moonbase scripts/deploy.js
```

If you're using another Moonbeam network, make sure that you specify the correct network. The network name needs to match how it's defined in the `hardhat.config.js`.

您也可以使用Moonbeam网络，请确保指定正确的网络。网络名称需要与`hardhat.config.js`中定义的保持一致。

After a few seconds, the contract is deployed, and you should see the address in the terminal. Save the address, as we will use it to interact with this contract instance in the next step.

几分钟后，合约成功部署，您将在终端看到地址。保存地址，我们将在下一部分中用于合约实例交互。

![Deploy the Lottery contract using Hardhat's run command.](/images/tutorials/eth-api/randomness-lottery/lottery-3.png)

### Create Scripts to Interact with the Lottery Contract - 创建脚本以与Lottery合约交互 {: #participate-in-lottery }

We can continue to work with our Hardhat project and create additional scripts to interact with our lottery contract and call some of it's functions. For example, to participate in the lottery, we can create another script in our `scripts` directory:

我们可以继续使用我们的Hardhat项目，另外创建额外的脚本来与lottery合约交互并调用它的一些功能。例如，参加lottery，我们可以在`scripts`目录中创建另一个脚本：

```
touch participate.js
```

Then we can add the following code, which will create an instance of the lottery contract using the name of the contract and the contract address. Then we can obtain the participation fee directly from the contract and call the contract's `participate` function:

然后，我们可以添加以下代码，这将使用合约名称和合约地址创建lottery合约的实例。接下来，我们可以直接从合约获取参与费用和调用合约的`participate`函数：

```js
async function participate() {
    const lottery = await ethers.getContractAt('Lottery', 'INSERT-CONTRACT-ADDRESS');

    const participationFee = await lottery.PARTICIPATION_FEE();
    const tx = await lottery.participate({ value: participationFee });
    console.log('Participation transaction hash:', tx.hash);
}

participate()
    .then(() => process.exit(0))
    .catch((error) => {
        console.error(error);
        process.exit(1);
    });
```

To run this script, you can use the following command: 

要运行此脚本，您可以使用以下命令：

```
npx hardhat run --network moonbase scripts/participate.js
```

The transaction hash will be printed to the console. You can use the hash to look up the transction on [Moonscan](https://moonbase.moonscan.io){target=_blank}.

交易哈希将在后台显示。您可以使用哈希在[Moonscan](https://moonbase.moonscan.io){target=_blank}查看交易。

![Run the partipation script using Hardhat's run command.](/images/tutorials/eth-api/randomness-lottery/lottery-4.png)

And that's it! You can feel free to continue creating additional scripts to perform the next steps of the lottery, such as starting the lottery and picking the winners.

这样就可以了！您可以继续创建另外的脚本来执行lottery的后续步骤，例如启动lottery和挑选获胜者。

--8<-- 'text/disclaimers/educational-tutorial.md'

--8<-- 'text/disclaimers/third-party-content.md'