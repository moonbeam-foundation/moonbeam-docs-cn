---
title: 随机数预编译
description: 学习如何使用Moonbeam上的VRF随机数资源以及如何使用随机数预编译和消费者接口生成链上随机数
keywords: solidity, ethereum, randomness, VRF, moonbeam, precompiled, contracts
---

# Interacting with the Randomness Precompile 与随机数预编译交互

![Randomness Moonbeam Banner](/images/builders/pallets-precompiles/precompiles/randomness/randomness-banner.png)

## Introduction {: #introduction } 概览 {: #introduction }

Moonbeam utilizes verifiable random functions (VRF) to generate randomness that can be verified on-chain. A VRF is a cryptographic function that takes some input and produces random values, along with a proof of authenticity that these random values were generated by the submitter. The proof can be verified by anyone to ensure the random values generated were calculated correctly.

Moonbeam使用可验证随机函数（Verifiable Random Functions，VRF）生成可以在链上验证的随机数。VRF是一种利用一些输入值并产生随机数的加密函数，并证明这些数值是由提交者生成。此证明可以由任何人验证，以确保准确计算生成的随机数计算。

There are two available sources of randomness that provide random inputs based on block producers' VRF keys and past randomness results: [local VRF](#local-vrf) and [BABE epoch randomness](#babe-epoch-randomness). Local VRF is determined directly within Moonbeam using the collator of the block's VRF key and the last block's VRF output. On the other hand, [BABE](https://wiki.polkadot.network/docs/learn-consensus#block-production-babe){target=_blank} epoch randomness is based on all the VRF produced by the relay chain validators during a complete [epoch](https://wiki.polkadot.network/docs/glossary#epoch){target=_blank}.

目前有两种提供随机输入的可用随机数来源，分别基于区块生产者的VRF私钥以及过去的随机数结果：[本地VRF](#local-vrf)和[BABE Epoch随机数](#babe-epoch-randomness)。本地VRF在Moonbeam中使用区块的VRF私钥以及最新区块的VRF输出值决定。而[BABE](https://wiki.polkadot.network/docs/learn-consensus#block-production-babe){target=_blank} Epoch随机数基于所有由中继链验证人在完整Epoch期间生产的VRF{target=_blank}。

For more information on the two sources of randomness, how the request and fulfillment process works, and security considerations, please refer to the [Randomness on Moonbeam](/learn/features/randomness){target=_blank} page.

关于更多两种随机数来源的信息，如何请求和完成工作流程以及安全考虑，请查看[Moonbeam上的随机数](/learn/features/randomness){target=_blank}页面。

Moonbeam provides a randomness precompile, which is a Solidity interface that enables smart contract developers to generate randomness via local VRF or BABE epoch randomness using the Ethereum API. Moonbeam also provides a randomness consumer Solidity contract that your contract must inherit from in order to consume fulfilled randomness requests.

Moonbeam提供一个随机数预编译，其为一个允许智能合约开发者使用以太坊API通过本地VRF或BABE Epoch随机数来生成随机数。Moonbeam同样提供一个随机数消费者Solidity合约，您的合约必须继承此Solidity合约才能实现已完成的随机数请求。

This guide will show you how to use the randomness precompile and randomness consumer contract to create a lottery where the winners will randomly be selected. You'll also learn how to interact with the randomness precompile directly to perform actions such as purging an expired randomness request.

此教程将会包含如何使用随机数预编译以及随机数消费者合约创建一个随机选取赢家的彩票。同时，您将学习如何直接与随机数预编译交互以执行操作，例如清除过期的随机数请求。

The randomness precompile is currently only available on Moonbase Alpha and is located at the following address:

随机数预编译合约目前仅在Moonbase Alpha上可用，地址如下：

=== "Moonbase Alpha"
     ```
     {{ networks.moonbase.precompiles.randomness }}
     ```

## The Randomness Solidity Interface {: #the-randomness-interface } 随机数Solidity接口 {: #the-randomness-interface }

[Randomness.sol](https://github.com/PureStake/moonbeam/blob/master/precompiles/randomness/Randomness.sol#L4-L11){target=_blank} is a Solidity interface that allows developers to interact with the precompile's methods.

[Randomness.sol](https://github.com/PureStake/moonbeam/blob/master/precompiles/randomness/Randomness.sol#L4-L11){target=_blank}为一个允许开发者与预编译方法交互的Solidity接口。

The interface includes functions, constants, events, and enums, as covered in the following sections.

此接口包含函数、常量、事件以及枚举，如下列部分所包含。

### Functions {: #functions } 函数 {: #functions }

The interface includes the following functions:

此接口包含以下函数：

- **relayEpochIndex**() — returns the current relay epoch index, where an epoch represents real time and not a block number
- **relayEpochIndex**() — 返回当前的中继Epoch索引，Epoch代表当前实际时间而非区块编号
- **requiredDeposit**() — returns the deposit required to perform a randomness request
- **requiredDeposit**() — 返回使用随机数请求要求的保证金
- **getRequestStatus**(*uint256* requestId) — returns the request status of a given randomness request
- **getRequestStatus**(*uint256* requestId) — 根据给定的随机数请求返回请求状态
- **getRequest**(*uint256* requestId) — returns the request details of a given randomness request
- **getRequest**(*uint256* requestId) — 根据给定的随机数请求返回请求细节
- **requestLocalVRFRandomWords**(*address* refundAddress, *uint256* fee, *uint64* gasLimit, *bytes32* salt, *uint8* numWords, *uint64* delay) — request random words generated from the parachain VRF
- **requestLocalVRFRandomWords**(*address* refundAddress, *uint256* fee, *uint64* gasLimit, *bytes32* salt, *uint8* numWords, *uint64* delay) — 请求由平行链VRF生成的随机词
- **requestRelayBabeEpochRandomWords**(*address* refundAddress, *uint256* fee, *uint64* gasLimit, *bytes32* salt, *uint8* numWords) — request random words generated from the relay chain BABE consensus 
- **requestRelayBabeEpochRandomWords**(*address* refundAddress, *uint256* fee, *uint64* gasLimit, *bytes32* salt, *uint8* numWords) — 请求由中继链BABE共识生成的随机词
- **fulfillRequest**(*uint256* requestId) — fulfill the request which will call the consumer contract method [`fulfillRandomWords`](#:~:text=rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords)). Fees of the caller are refunded if the request is fulfillable
- **fulfillRequest**(*uint256* requestId) — 完成调用消费者合约方法[`fulfillRandomWords`](#:~:text=rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords))的请求。调用者的费用将会在请求可完成后退还
- **increaseRequestFee**(*uint256* requestId, *uint256* feeIncrease) — increases the fee associated with a given randomness request. This is needed if the gas price increases significantly before the request is fulfilled
- **increaseRequestFee**(*uint256* requestId, *uint256* feeIncrease) — 根据给定的随机数请求提高相关费用。此适用于在请求被完成前Gas价格突然升高的情况
- **purgeExpiredRequest**(*uint256* requestId) — removes a given expired request from storage and transfers the request fees to the caller and the deposit back to the 
- **purgeExpiredRequest**(*uint256* requestId) — 从存储库中移除给定的过期请求，并将请求费用和保证金转移给调用者

Where the inputs that need to be provided can be defined as:

以下为需要被定义的输入值：

- **requestId** - the ID of the randomness request
- **requestId** - 随机数请求的ID
- **refundAddress** - the address receiving the left-over fees after the fulfillment
- **refundAddress** - 过程完成后收取剩余费用的地址
- **fee** - the amount to set aside to pay for the fulfillment
- **fee** - 设定为支付完成费用的数值
- **gasLimit** - the gas limit to use for the fulfillment
- **gasLimit** - 用于完成请求设置的Gas限制
- **salt** - a string that is mixed with the randomness seed to obtain different random words
- **salt** - 包含随机数种子以获得不同随机词的字符串
- **numWords** - the number of random words requested, up to the maximum number of random words
- **numWords** - 请求的随机词数量，最大至随机词的生成最大数值
- **delay** - the number of blocks that must pass before the request can be fulfilled. This value will need to be between the minimum and maximum number of blocks before a local VRF request can be fulfilled
- **delay** - 在请求被完成前所需要经过的区块数量。此数值将需要在本地VRF请求能被完成的最大和最小区块数值之间
- **feeIncrease** - the amount to increase fees by
- **feeIncrease** - 需要提高费用的数值

### Constants {: #constants } 常量 {: #constants }

The interface includes the following constants:

此接口包含以下常量：

- **MAX_RANDOM_WORDS** - the maximum number of random words being requested 
- **MAX_RANDOM_WORDS** - 被请求的随机词的最大值
- **MIN_VRF_BLOCKS_DELAY** - the minimum number of blocks before a request can be fulfilled for local VRF requests
- **MIN_VRF_BLOCKS_DELAY** - 在请求能被本地VRF请求完成前的最小区块数量
- **MAX_VRF_BLOCKS_DELAY** - the maximum number of blocks before a request can be fulfilled for local VRF requests
- **MAX_VRF_BLOCKS_DELAY** - 在请求能被本地VRF请求完成前的最大区块数量
- **REQUEST_DEPOSIT_AMOUNT** - the deposit amount needed to request random words. There is one deposit per request
- **REQUEST_DEPOSIT_AMOUNT** - 请求随机词所需的保证金。每个请求需要一笔保证金

=== "Moonbase Alpha"
    |        Variable        |                             Value                              |
    |:----------------------:|:--------------------------------------------------------------:|
    |    MAX_RANDOM_WORDS    |   {{ networks.moonbase.randomness.max_random_words }} words    |
    |  MIN_VRF_BLOCKS_DELAY  | {{ networks.moonbase.randomness.min_vrf_blocks_delay }} blocks |
    |  MAX_VRF_BLOCKS_DELAY  | {{ networks.moonbase.randomness.max_vrf_blocks_delay }} blocks |
    | REQUEST_DEPOSIT_AMOUNT | {{ networks.moonbase.randomness.req_deposit_amount.dev }} DEV  |

### Events {: #events } 事件 {: #events }

The interface includes the following events:

此接口包含以下事件：

- **FulfillmentSucceeded**() - emitted when the request has been successfully executed
- **FulfillmentSucceeded**() - 在请求被成功执行后发起
- **FulfillmentFailed**() - emitted when the request has failed to execute fulfillment
- **FulfillmentFailed**() - 在请求执行失败后发起

### Enums {: #enums } 枚举 {: #enums }

The interface includes the following enums:

以下接口包含下列枚举：

- **RequestStatus** - the status of the request, which can be `DoesNotExist` (0), `Pending` (1), `Ready` (2), or `Expired` (3)
- **RequestStatus** - 请求的状态，分别能为`DoesNotExist` (0)、`Pending` (1)、`Ready` (2)或`Expired` (3)
- **RandomnessSource** - the type of the randomness source, which can be `LocalVRF` (0) or `RelayBabeEpoch` (1)
- **RandomnessSource** - 随机数资源的类型，分别能为`LocalVRF` (0)或`RelayBabeEpoch` (1)

## The Randomness Consumer Solidity Interface {: #randomness-consumer-solidity-interface } 随机数消费者Solidity接口 {: #randomness-consumer-solidity-interface }

The [`RandomnessConsumer.sol`](https://github.com/PureStake/moonbeam/blob/4e2a5785424be6faa01cd14e90155d9d2ec734ee/precompiles/randomness/RandomnessConsumer.sol){target=_blank} Solidity interface makes it easy for smart contracts to interact with the randomness precompile. Using the randomness consumer ensures the fulfillment comes from the randomness precompile. 

[`RandomnessConsumer.sol`](https://github.com/PureStake/moonbeam/blob/4e2a5785424be6faa01cd14e90155d9d2ec734ee/precompiles/randomness/RandomnessConsumer.sol){target=_blank} Solidity接口使智能合约能够更简单地与随机数预编译交互。使用随机数消费者能确保完成来自随机数预编译。

The consumer interface includes the following functions:

消费者接口包含以下函数：

- **fulfillRandomWords**(*uint256* requestId, *uint256[] memory* randomWords) - handles the VRF response for  given request. This method is triggered by a call to `rawFulfillRandomWords`
- **fulfillRandomWords**(*uint256* requestId, *uint256[] memory* randomWords) - 根据给定的请求处理VRF回应，此函数将会通过`rawFulfillRandomWords`的调用而启动
- **rawFulfillRandomWords**(*uint256* requestId, *uint256[] memory* randomWords) - executed when the [`fulfillRequest` function](#:~:text=fulfillRequest(uint256 requestId)) of the randomness precompile is called. The origin of the call is validated, ensuring the randomness precompile is the origin, and then the `fulfillRandomWords` method is called
- **rawFulfillRandomWords**(*uint256* requestId, *uint256[] memory* randomWords) - 在随机数预编译的[`fulfillRequest`函数](#:~:text=fulfillRequest(uint256 requestId))被调用时启动。调用的源头将被验证，确保随机数预编译为调用的源头以及`fulfillRandomWords`方法确实被调用

## Request & Fulfill Process {: #request-and-fulfill-process } 请求和完成过程 {: #request-and-fulfill-process }

To consume randomness, you must have a contract that does the following:

要启用随机性，您必须有一个执行以下操作的合约：

  - Imports the `Randomness.sol` precompile and `RandomnessConsumer.sol` interface
  - 导入`Randomness.sol`预编译和`RandomnessConsumer.sol`接口
  - Inherits from the `RandomnessConsumer.sol` interface
  - 从`RandomnessConsumer.sol`接口继承
  - Requests randomness through the precompile's [`requestLocalVRFRandomWords` method](#:~:text=requestLocalVRFRandomWords) or [`requestRelayBabeEpochRandomWords` method](#:~:text=requestRelayBabeEpochRandomWords), depending on the source of randomness you want to use
  - 根据您希望使用的随机数资源，通过预编译的[`requestLocalVRFRandomWords`方法](#:~:text=requestLocalVRFRandomWords)或[`requestRelayBabeEpochRandomWords`方法](#:~:text=requestRelayBabeEpochRandomWords)请求随机数
  - Requests fulfillment through the precompile's [`fulfillRequest` method](#:~:text=fulfillRequest)
  - 通过预编译的[`fulfillRequest`方法](#:~:text=fulfillRequest)完成请求
  - Consumes randomness through a `fulfillRandomWords` method with the same [signature as the `fulfillRandomWords` method](#:~:text=fulfillRandomWords(uint256 requestId, uint256[] memory randomWords)) of the `RandomnessConsumer.sol` contract
  - 使用与[`fulfillRandomWords`方法相同的签名](#:~:text=fulfillRandomWords(uint256 requestId, uint256[] memory randomWords))通过`fulfillRandomWords`方法使用随机数

When randomness is requested through the precompile's `requestLocalVRFRandomWords` or `requestRelayBabeEpochRandomWords` method, a fee is set aside to pay for the fulfillment of the request. When using local VRF, to increase unpredictability, a specified delay period (in blocks) must pass before the request can be fulfilled. At the very least, the delay period must be greater than one block. For BABE epoch randomness, you do not need to specify a delay but can fulfill the request at the beginning of the 2nd epoch following the current one.

通过预编译的`requestLocalVRFRandomWords`或`requestRelayBabeEpochRandomWords`方法请求随机数时，将会设置一个用于支付请求完成过程的费用。当使用本地VRF时，为提高不可预测性，制定的延迟时间段（以区块计算）将需要在请求被完成时经过。在最后，延迟的时间段必须大于一个区块。至于BABE Epoch随机数，您不需要制定一个延迟时间段，而可以在当前Epoch的第二个Epoch完成要求。

After the delay, fulfillment of the request can be manually executed by anyone through the `fulfillRequest` method using the fee that was initially set aside for the request.

延迟时间段过后，请求的完成可以由任何人使用`fulfillRequest`方法以及先前在提交要求时设置的费用完成请求。

When fulfilling the randomness request via the precompile's `fulfillRequest` method, the [`rawFulfillRandomWords`](#:~:text=rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords)) function in the `RandomnessConsumer.sol` contract will be called, which will verify that the sender is the randomness precompile. From there, [`fulfillRandomWords`](#:~:text=fulfillRandomWords(uint256 requestId, uint256[] memory randomWords)) is called and the requested number of random words are computed using the current block's randomness result and a given salt and returned. If the fulfillment was successful, the [`FulfillmentSucceeded` event](#:~:text=FulfillmentSucceeded) will be emitted; otherwise the [`FulfillmentFailed` event](#:~:text=FulfillmentFailed) will be emitted. 

在通过预编译的`fulfillRequest`方法完成随机数请求时，`RandomnessConsumer.sol`合约中的 [`rawFulfillRandomWords`](#:~:text=rawFulfillRandomWords(uint256 requestId, uint256[] memory randomWords))函数将会被调用，其将会验证传送者为随机预编译。自其， [`fulfillRandomWords`](#:~:text=fulfillRandomWords(uint256 requestId, uint256[] memory randomWords))将被调用而请求的随机词数量将由当前区块的随机数结果以及给定的salt计算并得出。如果整个过程是成功的，[`FulfillmentSucceeded`事件](#:~:text=FulfillmentSucceeded)将被触发，否则[`FulfillmentFailed`事件](#:~:text=FulfillmentFailed)将被触发。

For fulfilled requests, the cost of execution will be refunded from the request fee to the caller of `fulfillRequest`. Then any excess fees and the request deposit are transferred to the specified refund address.

至于已完成的请求，执行的费用将会从请求费用退还给`fulfillRequest`调用者。任何剩余的费用以及要求的保证金将被转移回指定的退还地址。

Your contract's `fulfillRandomWords` callback is responsible for handling the fulfillment. For example, in a lottery contract, the callback would use the random words to choose a winner and payout the winnings.

您合约的`fulfillRandomWords`回调将负责处理整个完成过程。举例来说，在彩票合约中，回调将会使用随机词选取赢家并支付奖品。

If a request expires it can be purged through the precompile's [`purgeExpiredRequest` function](/buildxers/pallets-precompiles/precompiles/randomness/#:~:text=purgeExpiredRequest){target=_blank}. When this function is called the request fee is paid out to the caller and the deposit will be returned to the original requester.

如果一个请求已经过期，它可以通过预编译的[`purgeExpiredRequest`函数](/buildxers/pallets-precompiles/precompiles/randomness/#:~:text=purgeExpiredRequest){target=_blank}删除。当此函数被调用且请求费用已经被支付给调用者，保证金将被退还给原先的请求者。

The happy path for a randomness request is shown in the following diagram:

随机数请求的过程如下所示：

![Randomness request happy path diagram](/images/learn/features/randomness/randomness-1.png)

## Interact with the Solidity Interfaces via Lottery Contract {: #interact-with-the-solidity-interfaces } 通过彩票合约与Solidity接口交互 {: #interact-with-the-solidity-interfaces }

In the following sections of this tutorial, you'll learn how to interact with the randomness precompile, in addition to a lottery contract that requires you to have multiple accounts which you can use to participate in a lottery. The default lottery contract sets the minimum number of participants to three, however you can feel free to change the number in the contract. 

在接下来的教程中，您将会学习如何与随机数预编译交互，包含需要您拥有多个账户以参与彩票抽奖的彩票合约。预设彩票合约将最小参与者人量设置为3，然而您可以根据需求更改合约中的数值。

### Checking Prerequisites {: #checking-prerequisites } 查看先决条件 {: #checking-prerequisites }

Assuming you use the default contract, you will need to have the following:

如您使用预设合约，您需要准备以下内容：

- [MetaMask installed and connected to Moonbase Alpha](/tokens/connect/metamask/){target=_blank}
- [安装成功的MetaMask并连接至Moonbase Alpha](/tokens/connect/metamask/){target=_blank}
- Create or have three accounts on Moonbase Alpha to test out the lottery contract
- 在Moonbase Alpha上创建或是拥有3个账户以测试彩票合约
- All of the accounts will need to be funded with `DEV` tokens.
- 所有账户皆需拥有`DEV ` Token
 --8<-- 'text/faucet/faucet-list-item.md'

### Example Lottery Contract {: #example-contract } 范例彩票合约 {: #example-contract }

In this tutorial, you'll interact with a lottery contract that uses the randomness precompile and consumer. You'll be generating random words which will be used to select the winner of the lottery fairly. You can find a copy of the lottery contract that will be used for this tutorial, [`RandomnessLotteryDemo.sol`](https://raw.githubusercontent.com/PureStake/moonbeam-docs/blob/master/.snippets/code/randomness/RandomnessLotteryDemo.sol){target=_blank}, in the Moonbeam Docs GitHub repository.

在此教程中，您将会与使用随机数预编译和消费者接口的彩票合约交互。您将会生成用于公平选取彩票获胜者的随机词。您可以在Moonbeam Docs GitHub库中寻找将被用于此教程的彩票合约文档，[`RandomnessLotteryDemo.sol`](https://raw.githubusercontent.com/PureStake/moonbeam-docs/blob/master/.snippets/code/randomness/RandomnessLotteryDemo.sol){target=_blank}。

The lottery contract imports the `Randomness.sol` precompile and the `RandomnessConsumer.sol` interface, and inherits from the consumer contract. In the constructor of the contract, you can specify the source of randomness to be either local VRF or BABE epoch randomness.

此彩票合约导入`Randomness.sol`预编译以及`RandomnessConsumer.sol`接口，并衍生自客户合约。在合约的架构中，您可以制定随机数的来源为本地VRF或BABE Epoch随机数。

In general, the lottery contract includes functionality to check the status of the randomness request which will be used to determine whether the lottery is still accepting participants, if it has started, or if it has expired. It will use the `requestLocalVRFRandomWords` or `requestRelayBabeEpochRandomWords` function to select the random words, depending on which source of randomness you want to use. In addition, it will implement the `fulfillRandomWords` method and the callback will fulfill the request and use the random words to randomly pick the lottery winners.

一般而言，彩票合约包含查看随机数请求状态的功能，其将被用于决定彩票是否将持续接受新的参与者、是否开始或是否过期。它将会根据您希望使用的随机数来源使用`requestLocalVRFRandomWords`或`requestRelayBabeEpochRandomWords`函数选取随机词。除外，它将会执行`fulfillRandomWords`方法并回调将会完成请求以及使用随机词随机地选取彩票获胜者。

There are also some constants in the contract that can be edited as you see fit, especially the `SALT_PREFIX` which can be used to produce unique results.

同样合约中具有一些能够编辑的常量，尤其是能够用于产生独特结果的`SALT_PREFIX` 。

### Remix Set Up {: #remix-set-up } Remix设置 {: #remix-set-up }

You can interact with the randomness precompile and consumer using [Remix](https://remix.ethereum.org/){target=_blank}. To add the interfaces to Remix and follow along with the tutorial, you will need to:

您可以使用[Remix](https://remix.ethereum.org/){target=_blank}与随机数预编译和消费者合约交互。要将接口新增至Remix并跟随其后教程，您需要跟随以下步骤：

1. Get a copy of [`RandomnessLotteryDemo.sol`](https://github.com/PureStake/moonbeam/blob/4e2a5785424be6faa01cd14e90155d9d2ec734ee/tests/contracts/solidity/RandomnessLotteryDemo.sol){target=_blank}

   复制[`RandomnessLotteryDemo.sol`](https://github.com/PureStake/moonbeam/blob/4e2a5785424be6faa01cd14e90155d9d2ec734ee/tests/contracts/solidity/RandomnessLotteryDemo.sol){target=_blank}文件

2. Paste the file contents into a Remix file named **RandomnessLotteryDemo.sol**

   将文件内容粘贴至一个命名为**RandomnessLotteryDemo.sol**的文件

![Add contracts to Remix](/images/builders/pallets-precompiles/precompiles/randomness/randomness-1.png)

### Compile & Deploy the Lottery Contract {: #compile-lottery } 编译并部署彩票合约 {: #compile-lottery }

Next, you will need to compile the `RandomnessLotteryDemo.sol` file in Remix:

接着，您需要在Remix中编译`RandomnessLotteryDemo.sol`文件：

1. Make sure that you have the **RandomnessLotteryDemo.sol** file open

   确保**RandomnessLotteryDemo.sol**文件已打开

2. Click on the **Compile** tab, second from top

   点击从上至下的第二个**Compile**标签

3. To compile the contract, click on **Compile RandomnessLotteryDemo.sol**

   点击**Compile RandomnessLotteryDemo.sol**编译合约

![Compile RandomnessLotteryDemo](/images/builders/pallets-precompiles/precompiles/randomness/randomness-2.png)

If the contract was compiled successfully, you will see a green checkmark next to the **Compile** tab.

如果合约成功被编译，您将会在**Compile**标签旁看见绿色的打勾标志。

Once the contract has been compiled, you can deploy the contract by taking the following steps:

当合约成功被编译，您可以跟随以下步骤部署合约：

1. Click on the **Deploy and Run** tab directly below the **Compile** tab in Remix

   在Remix中的**Compile**标签下方点击**Deploy and Run**标签

2. Make sure **Injected Provider - Metamask** is selected in the **ENVIRONMENT** dropdown. Once selected, you might be prompted by MetaMask to connect your account to Remix

   确保在**ENVIRONMENT**下拉菜单中的**Injected Provider - Metamask**已被选取。选取后，您将会看见MetaMask跳出弹窗要求您将账户连接至Remix

3. Make sure the correct account is displayed under **ACCOUNT**

   确保正确的账户在**ACCOUNT**下方显示

4. You'll need to pay the required deposit for a randomness request. For this contract, the required deposit is {{ networks.moonbase.randomness.req_deposit_amount.dev }} DEV. So set the value to `{{ networks.moonbase.randomness.req_deposit_amount.wei }}` and choose **Wei** from the dropdown on the right

   您将会需要为随机数请求支付所需的保证金。以此合约来说，需要的保证金为{{ networks.moonbase.randomness.req_deposit_amount.dev }}个DEV。因此将数值设定为`{{ networks.moonbase.randomness.req_deposit_amount.wei }}`并在右方的下拉菜单中选取**Wei**

5. Ensure **RandomnessLotteryDemo - RandomnessLotteryDemo.sol** is selected in the **CONTRACT** dropdown

   确保**CONTRACT**下拉菜单中的**RandomnessLotteryDemo - RandomnessLotteryDemo.sol**已被选取

6. Next to **Deploy** enter the source of randomness. This corresponds to the [`RandomnessSource`](#enums) enum. For local VRF, enter `0`, and for BABE epoch randomness, enter `1`. To follow along with this example, you can select `0` and click **Deploy**

   接着在**Deploy**旁输入随机数来源，这与[`RandomnessSource`](#enums)枚举相关。以本地VRF来说，输入`0`，BABE Epoch随机数的话，请输入`1`。为跟随此范例，您可以输入`0`并点击**Deploy**

7. Confirm the MetaMask transaction that appears by clicking **Confirm**

   在MetaMask弹窗中点击**Confirm**确认交易

![Deploy RandomnessLotteryDemo](/images/builders/pallets-precompiles/precompiles/randomness/randomness-3.png)

The **RANDOMNESSLOTTERYDEMO** contract will appear in the list of **Deployed Contracts**.

**RANDOMNESSLOTTERYDEMO**合约将出现在**Deployed Contracts**的列表之中。

### Participate in the Lottery {: #participate-in-lottery } 参与彩票 {: #participate-in-lottery }

The default contract has a minimum requirement of three participants. To participate you can take the following steps:

预设合约需要最少3跟参与者，您可以跟随以下步骤参与：

1. Make sure you've switched to the account you want to participate with in MetaMask. You can verify the account that is connected under **ACCOUNT** 

   确保您在MetaMask中切换至您希望用于参与的账户，您可以在**ACCOUNT**下方确认账户是否已连接

2. Enter the amount you want to contribute to the lottery in the **VALUE** field. It must be greater than or equal to the `PARTICIPATION_FEE` which is set to `100000 gwei` in the default contract

   在**VALUE**一栏输入您希望贡献值彩票池的数量，数值需大于或等于预设合约中设置的`100000 gwei`的`PARTICIPATION_FEE`

3. Click on **participate**

   点击**participate**

4. Confirm the transaction in MetaMask

   在MetaMask中确认交易

![Participate in the lottery](/images/builders/pallets-precompiles/precompiles/randomness/randomness-4.png)

Since there is a minimum of three participants required to start the lottery, you'll need to repeat these steps until you've participated from three different accounts.

由于最少需要3个人以开启彩票活动，您需要使用不同账户重复上述步骤以开启活动。

### Start the Lottery {: #start-the-lottery } 开启彩票活动 {: #start-the-lottery } 

If you take a closer look at the `RandomnessLotteryDemo.sol` contract's `startLottery` function, you'll notice that it has the `onlyOwner` modifier. As such, you will need to make sure that you switch back to the account that deployed the lottery contract before starting the lottery.

如果您仔细查看`RandomnessLotteryDemo.sol`合约中的`startLottery`函数，您将会注意到它有`onlyOwner`修饰符。因此，您将需要确认在开始彩票活动之前切换为先前部署此合约的账户。

To start the lottery and submit the randomness request, which will call the precompile's `requestLocalVRFRandomWords`, you can take the following steps:

要开始抽奖并提交随机数请求（这将调用预编译的`requestLocalVRFRandomWords`），您可以跟随以下步骤：

1. Confirm the account is the owner

   确认账户属于所有人

2. To start the lottery you need to pay a fee which will be used to fulfill the randomness request. You can set the **VALUE** to `200000` and choose **Gwei**. The excess fee will be returned to the `msg.sender`

   您需要支付费用以开启抽奖，其将用于完成随机数请求。您可以将**VALUE**设置为`200000`并选取**Gwei**，超过的费用将被退还给`msg.sender`

3. Click on **startLottery**

   点击**startLottery**

4. Confirm the transaction in MetaMask

   在MetaMask之中确认交易

![Start the lottery](/images/builders/pallets-precompiles/precompiles/randomness/randomness-5.png)

Once the transaction goes through, the lottery will start and no more participants will be able to join. Before you can fulfill the randomness request in order to pick the winners, you'll need to wait the delay. The default `VRF_BLOCKS_DELAY` is set to `2` blocks.

当交易完成，彩票活动将会开始并不让任何人加入。在您完成随机数请求以挑选获胜者之前，您需要等待延迟，预设`VRF_BLOCKS_DELAY`为`2`个区块。

### Pick the Winners {: #pick-the-winners } 挑选获胜者 {: #pick-the-winners }

To fulfill the request, you can do so using the `fulfillRequest` function which will use the contract's `requestId` variable to call the `fulfillRequest` function of the randomness precompile. If successful, the request will be fulfilled and generate the random words and execute the `fulfillRandomWords` function defined in the `RandomnessLotteryDemo.sol` contract. The `fulfillRandomWords` function callback then calls `pickWinners` and the jackpot is distributed to the randomly selected winners. In addition, the cost of execution will be refunded from the request fee to the caller of `fulfillRequest`. Then any excess fees and the request deposit are transferred to the specified refund address.

要完成请求，您可以使用`fulfillRequest`函数来，该函数将使用合约的`requestId`变量来调用随机数预编译的`fulfillRequest`函数。如果成功，请求将被完成且会生成随机词并执行`RandomnessLotteryDemo.sol`合约中定义的`fulfillRandomWords`函数。 `fulfillRandomWords`函数回调后将调用`pickWinners`并将累积奖金分配给随机选取的获胜者。此外，执行费用将从请求费用中退还给`fulfillRequest`的调用者。然后，任何剩余费用和要求的保证金都会被转移到指定的退款地址。

You can initiate the fulfillment from any account after the delay has passed, to do so you'll need to:

您可以在延迟经过后在任何账户跟随以下步骤发起完成请求：

1. Ensure you're connected to the account that you want to fulfill the request from, it can be any account you choose

   确保您连接至您希望完成请求的账户，可以是任何账户

2. Click on **fulfillRequest**

   点击**fulfillRequest**

3. Confirm the transaction in MetaMask

   在MetaMask中确认交易

![Fulfill the randomness request](/images/builders/pallets-precompiles/precompiles/randomness/randomness-6.png)

If the transaction reverts with the following error you may need to call `increaseRequestFee`:

如果交易显示以下错误，您可以调用`increaseRequestFee`：

```
{ 
  "code": -32603,
  "message": "VM Exception while processing transaction: revert",
  "data": "0x476173206c696d69742061742063757272656e74207072696365206d757374206265206c657373207468616e206665657320616c6c6f74746564"
}
```

The `data` field converted to ASCII text reads: `Gas limit at current price must be less than fees allotted`. As such, you can use the `increaseRequestFee` function to increase the fees for the transaction and try again.

`data`被转移为ASCII文本阅读为：`Gas limit at current price must be less than fees allotted`。因此，您可以使用`increaseRequestFee`函数为交易提高费用并重新尝试。

Once the transaction goes through, you can take a look at the transaction details in the Remix console. If you scroll down til you see the **logs**, you should see four events and the event details. The events you should see are:

当交易完成，您可以在Remix控制台查看交易细节。您可以下滑页面查看**logs**，您应当看到4个事件以及事件细节。以下为您应当看到的事件：

- **`"event": "Ended"`** - event sent when the lottery ends, which emits the number of participants, the jackpot, and the total winners. Defined in the `RandomnessLotteryDemo.sol` contract
- **`"event": "Ended"`** - 在彩票活动结束后传送的事件，这将触发参与者数量、头奖以及整体获胜者数量。在`RandomnessLotteryDemo.sol`合约中被定义
- **`"event": "Awarded"`** - event sent when a winner is awarded, which should get emitted twice since there are two winners per the default contract. It emits the winner, the random word, and the amount won. Defined in the `RandomnessLotteryDemo.sol` contract
- **`"event": "Awarded"`** - 在获胜者获得奖励后传送的事件，将被触发两次因预设合约中设定为2个设置。其将会触发获胜者、随机词以及获胜数量。在`RandomnessLotteryDemo.sol`合约中被定义
- **`"event": "FulFillmentSucceeded"`** - event sent when a request has been fulfilled successfully. Defined in the `Randomness.sol` precompile
- **`"event": "FulFillmentSucceeded"`** - 在请求被成功完成后传送的事件。在`Randomness.sol`预编译中被定义

![Fulfill the randomness request](/images/builders/pallets-precompiles/precompiles/randomness/randomness-7.png)

Congratulations! You've successfully used the randomness precompile and consumer to participate in and start a lottery, and use the generated random words to select a winner.

恭喜！您已经成功使用随机数预编译和消费者合约参与和启用彩票活动，并使用随机词选取胜者。

## Interact with the Precompile Solidity Interface Directly {: #interact-directly } 直接与预编译Solidity接口交互 {: #interact-directly }

In addition to interacting with the randomness precompile via a smart contract, you can also interact with it directly in Remix to perform operations such as creating a randomness request, checking on the status of a request, and purging expired requests. Remember, you need to have a contract that inherits from the consumer contract in order to fulfill requests, as such if you fulfill a request using the precompile directly there will be no way to consume the results.

除了通过智能合约与随机预编译进行交互外，您还可以在Remix中直接与其交互以执行创建随机请求、检查请求状态和清除过期请求等操作。请记住，您需要有一个从消费者合约继承的合约才能满足请求，因此如果您直接使用预编译来完成请求，则无法使用结果。

### Remix Set Up {: #remix-set-up } Remix设置 {: #remix-set-up }

To add the interfaces to Remix and follow along with this section of the tutorial, you will need to:

要将接口添加至Remix并跟随以下教程步骤，您将需要：

1. Get a copy of [`Randomness.sol`](https://github.com/PureStake/moonbeam/blob/master/precompiles/randomness/Randomness.sol){target=_blank}

   复制[`Randomness.sol`](https://github.com/PureStake/moonbeam/blob/master/precompiles/randomness/Randomness.sol){target=_blank}

2. Paste the file contents into a Remix file named **Randomness.sol**

   在Remix文件中粘贴文件内容并命名为**Randomness.sol**

![Add precompile to Remix](/images/builders/pallets-precompiles/precompiles/randomness/randomness-8.png)

### Compile & Access the Randomness Precompile {: #compile-randomness } 编译和访问随机数预编译 {: #compile-randomness }

Next, you will need to compile the `Randomness.sol` file in Remix. To get started, make sure you have the **Randomness.sol** file open and take the following steps:

接着，您将需要在Remix中编译`Randomness.sol`文件。要开始操作，请确认您已打开**Randomness.sol**文件并跟随以下步骤：

1. Click on the **Compile** tab, second from top

   点击从上至下的第二个**Compile**标签

2. To compile the contract, click on **Compile Randomness.sol**

   点击**Compile Randomness.sol**编译合约

If the contract was compiled successfully, you will see a green checkmark next to the **Compile** tab.

如果合约被成功编译，您将在**Compile**标签旁看见绿色打勾标志。

Instead of deploying the randomness precompile, you will access the interface given the address of the precompiled contract:

您将会根据给定的预编译合约地址访问接口，而非部署随机数预编译：

1. Click on the **Deploy and Run** tab directly below the **Compile** tab in Remix. Please note the precompiled contract is already deployed

   在Remix中**Compile**标签下方点击**Deploy and Run**标签，请注意预编译合约已部署

2. Make sure **Injected Provider - Metamask** is selected in the **ENVIRONMENT** dropdown. Once selected, you might be prompted by MetaMask to connect your account to Remix

   确保在**ENVIRONMENT**下拉菜单中**Injected Provider - MetaMask**已选取。当选取时，MetaMask将跳出弹窗要求您将账户连接至Remix

3. Make sure the correct account is displayed under **ACCOUNT**

   确保正确的账户在**ACCOUNT**下方显示

4. Ensure **Randomness - Randomness.sol** is selected in the **CONTRACT** dropdown. Since this is a precompiled contract, there is no need to deploy any code. Instead we are going to provide the address of the precompile in the **At Address** Field

   确保**CONTRACT**下拉菜单中**Randomness - Randomness.sol**已被选取。由于此为预编译合约，因此并不需要部署任何代码，我们反而将会在**At Address**一栏中提供预编译地址

5. Provide the address of the batch precompile: `{{ networks.moonbase.precompiles.randomness }}` and click **At Address**

   提供批量预编译的地址`{{ networks.moonbase.precompiles.randomness }}`并点击**At Address**

![Access the address](/images/builders/pallets-precompiles/precompiles/randomness/randomness-9.png)

The **RANDOMNESS** precompile will appear in the list of **Deployed Contracts**. You will use this to fulfill the randomness request made from the lottery contract later on in this tutorial.

**RANDOMNESS**预编译将会出现在**Deployed Contracts**列表中，您将会用其完成后续教程中彩票合约的随机数请求。

### Get Request Status & Purge Expired Request {: #get-request-status-and-purge } 获得请求状态和删除过期请求 {: #get-request-status-and-purge }

Anyone can purge expired requests. You do not need to be the one who requested the randomness to be able to purge it. When you purge an expired request, the request fees will be transferred to you, and the deposit for the request will be returned to the original requester.

任何人都可以清除过期的请求。您不需要成为请求随机数者才能够清除它。当您清除过期的请求时，要求费用将转给您，要求的保证金将退还给请求发起者。

To purge a request, first you have to make sure that the request has expired. To do so, you can verify the status of a request using the `getRequestStatus` function of the precompile. The number that is returned from this call corresponds to the index of the value in the [`RequestStatus`](#enums) enum. As a result, you'll want to verify the number returned is `3` for `Expired`.

要清除请求，首先您必须确保请求已过期。为此，您可以使用预编译的`getRequestStatus`函数验证请求的状态。此调用返回的数字对应于[`RequestStatus`](#enums)枚举中值的索引。因此，您需要验证返回的数字是否为`3`表示`Expired`。

Once you've verified that the request is expired, you can call the `purgeExpiredRequest` function to purge the request. 

当您验证请求已过期，您可以调用`purgeExpiredRequest`函数清除此请求。

To verify and purge a request, you can take the following steps:

要验证和清除请求，您可以跟随以下步骤：

1. Expand the **RANDOMNESS** contract

   展开**RANDOMNESS**合约

2. Enter the request ID of the request you want to verify has expired and click on **getRequestStatus**

   输入您希望验证其是否过期的请求ID并点击**getRequestStatus**

3. The response will appear just underneath the function. Verify that you received a `3`

   回应将会出现在函数下方，验证您是否获得`3`

4. Expand the **purgeExpiredRequest** function and enter the request ID

   展开**purgeExpiredRequest**函数并输入要求ID

5. Click on **transact**

   点击**transact**

6. MetaMask will pop-up and you can confirm the transaction

   MetaMask将会跳出弹窗，请确认交易

![Purge an exired request](/images/builders/pallets-precompiles/precompiles/randomness/randomness-10.png)

Once the transaction goes through, you can verify the request has been purged by calling the **getRequestStatus** function again with the same request ID. You should receive a status of `0`, or `DoesNotExist`. You can also expect the amount of the request fees to be transferred to your account.

交易完成后，您可以通过使用相同的请求ID再次调用**getRequestStatus**函数来验证请求已被清除。您应该收到`0`或`DoesNotExist`的状态。您还可以预期请求费用的金额将转入您的帐户。
